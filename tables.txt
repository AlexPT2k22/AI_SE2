-- =====================================================
-- TABELAS DO SISTEMA DE ESTACIONAMENTO v2.0
-- Sistema: 3 ESP32-CAM (entrada, centro, saída)
-- Fluxo: Registo → Login → Entrada → Estacionamento → Pagamento Automático → Saída
-- =====================================================

-- ⚠️ DROP ALL TABLES (começar do zero)
-- Ordem: tabelas filhas primeiro (por causa das foreign keys)
DROP TABLE IF EXISTS public.parking_notifications CASCADE;
DROP TABLE IF EXISTS public.parking_payments CASCADE;
DROP TABLE IF EXISTS public.parking_sessions CASCADE;
DROP TABLE IF EXISTS public.parking_manual_reservations CASCADE;
DROP TABLE IF EXISTS public.parking_user_vehicles CASCADE;
DROP TABLE IF EXISTS public.parking_user_payment_methods CASCADE;
DROP TABLE IF EXISTS public.parking_users CASCADE;
DROP TABLE IF EXISTS public.parking_event_log CASCADE;


-- =====================================================
-- 1. UTILIZADORES (NOVA ESTRUTURA)
-- =====================================================
-- Utilizadores registados com email, password e role

CREATE TABLE public.parking_users (
    id SERIAL PRIMARY KEY,
    email TEXT NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    full_name TEXT NOT NULL,
    role TEXT NOT NULL DEFAULT 'client' CHECK (role IN ('admin', 'client')),
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

CREATE INDEX idx_users_email ON public.parking_users(email);
CREATE INDEX idx_users_role ON public.parking_users(role);

COMMENT ON TABLE public.parking_users IS 'Utilizadores do sistema (admins e clientes)';
COMMENT ON COLUMN public.parking_users.role IS 'admin = acesso total | client = acesso limitado';
COMMENT ON COLUMN public.parking_users.password_hash IS 'Password encriptada com bcrypt';


-- =====================================================
-- 2. VEÍCULOS DOS UTILIZADORES (MULTI-CARROS)
-- =====================================================
-- Um utilizador pode ter vários carros

CREATE TABLE public.parking_user_vehicles (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES public.parking_users(id) ON DELETE CASCADE,
    plate TEXT NOT NULL,
    plate_norm TEXT NOT NULL,
    brand TEXT NULL,           -- Ex: "BMW", "Audi", "Renault"
    model TEXT NULL,           -- Ex: "Serie 3", "A4", "Clio"
    color TEXT NULL,           -- Ex: "Preto", "Branco", "Azul"
    is_primary BOOLEAN DEFAULT FALSE,  -- Carro principal do utilizador
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    CONSTRAINT unique_plate_norm UNIQUE (plate_norm)
);

CREATE INDEX idx_vehicles_user_id ON public.parking_user_vehicles(user_id);
CREATE INDEX idx_vehicles_plate_norm ON public.parking_user_vehicles(plate_norm);

COMMENT ON TABLE public.parking_user_vehicles IS 'Veículos registados por cada utilizador';
COMMENT ON COLUMN public.parking_user_vehicles.plate_norm IS 'Matrícula normalizada (UPPER, sem hífens/espaços)';
COMMENT ON COLUMN public.parking_user_vehicles.is_primary IS 'TRUE = carro principal para login com matrícula';


-- =====================================================
-- 3. MÉTODOS DE PAGAMENTO (CARTÕES)
-- =====================================================
-- Cartões de crédito para pagamento automático

CREATE TABLE public.parking_user_payment_methods (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES public.parking_users(id) ON DELETE CASCADE,
    card_type TEXT NOT NULL CHECK (card_type IN ('visa', 'mastercard', 'amex', 'other')),
    card_last_four TEXT NOT NULL,      -- Últimos 4 dígitos (ex: "4567")
    card_holder_name TEXT NOT NULL,    -- Nome no cartão
    expiry_month INTEGER NOT NULL CHECK (expiry_month BETWEEN 1 AND 12),
    expiry_year INTEGER NOT NULL,
    is_default BOOLEAN DEFAULT FALSE,  -- Cartão principal para débitos
    auto_pay BOOLEAN DEFAULT FALSE,    -- TRUE = débito automático na saída
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    -- Nota: NÃO guardamos o número completo do cartão (segurança)
    -- Para simulação, vamos assumir que os pagamentos são sempre aprovados
    CONSTRAINT unique_card_per_user UNIQUE (user_id, card_last_four)
);

CREATE INDEX idx_payment_methods_user_id ON public.parking_user_payment_methods(user_id);

COMMENT ON TABLE public.parking_user_payment_methods IS 'Cartões de crédito para pagamento automático na saída';
COMMENT ON COLUMN public.parking_user_payment_methods.card_last_four IS 'Últimos 4 dígitos do cartão (para display)';


-- =====================================================
-- 4. RESERVAS (SEM DURAÇÃO - SÓ DATA)
-- =====================================================
-- Reservas para hoje ou amanhã apenas
-- Multa de 20€ se o carro não aparecer

CREATE TABLE public.parking_manual_reservations (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    user_id INTEGER NULL REFERENCES public.parking_users(id) ON DELETE CASCADE,
    spot TEXT NOT NULL,
    plate TEXT NOT NULL,
    plate_norm TEXT NOT NULL,
    reservation_date DATE NULL,        -- Data da reserva (só hoje ou amanhã) - para web
    reserved_by TEXT NULL,             -- Nome de quem reservou - para mobile
    reserved_until TIMESTAMPTZ NULL,   -- Validade da reserva em tempo - para mobile
    was_used BOOLEAN DEFAULT FALSE,    -- TRUE se o carro apareceu
    fine_applied BOOLEAN DEFAULT FALSE,-- TRUE se multa de 20€ foi aplicada
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    CONSTRAINT unique_spot_per_date UNIQUE (spot, reservation_date)
);

CREATE INDEX idx_reservations_user_id ON public.parking_manual_reservations(user_id);
CREATE INDEX idx_reservations_plate_norm ON public.parking_manual_reservations(plate_norm);
CREATE INDEX idx_reservations_date ON public.parking_manual_reservations(reservation_date);
CREATE INDEX idx_reservations_spot_date ON public.parking_manual_reservations(spot, reservation_date);

COMMENT ON TABLE public.parking_manual_reservations IS 'Reservas de vagas (só para hoje ou amanhã)';
COMMENT ON COLUMN public.parking_manual_reservations.reservation_date IS 'Data da reserva (apenas hoje ou dia seguinte permitido)';
COMMENT ON COLUMN public.parking_manual_reservations.was_used IS 'TRUE = carro apareceu no estacionamento nesse dia';
COMMENT ON COLUMN public.parking_manual_reservations.fine_applied IS 'TRUE = multa de 20€ aplicada por não usar a reserva';


-- =====================================================
-- 5. SESSÕES DE ESTACIONAMENTO
-- =====================================================
-- Entrada → Estacionamento → Pagamento Automático → Saída

CREATE TABLE public.parking_sessions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NULL REFERENCES public.parking_users(id) ON DELETE SET NULL,  -- NULL se utilizador não registado
    plate TEXT NOT NULL,
    plate_norm TEXT NULL,
    plate_country TEXT NULL,
    entry_time TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    exit_time TIMESTAMPTZ NULL,
    camera_id TEXT NULL,
    ticket_id TEXT UNIQUE NULL,
    spot TEXT NULL,                    -- Vaga onde estacionou
    amount_due NUMERIC(10, 2) NULL,    -- Valor a pagar
    amount_paid NUMERIC(10, 2) DEFAULT 0 NULL,
    payment_method_id INTEGER NULL REFERENCES public.parking_user_payment_methods(id) ON DELETE SET NULL,
    auto_payment_at TIMESTAMPTZ NULL,  -- Quando foi feito o débito automático
    payment_deadline TIMESTAMPTZ NULL, -- Prazo para sair após pagamento (10 min)
    status TEXT DEFAULT 'open' NOT NULL CHECK (status IN ('open', 'paid', 'closed', 'payment_pending', 'fine_pending')),
    notes TEXT NULL,
    entry_image_url TEXT NULL,
    exit_image_url TEXT NULL,
    CONSTRAINT parking_sessions_ticket_id_key UNIQUE (ticket_id)
);

CREATE INDEX idx_sessions_user_id ON public.parking_sessions(user_id);
CREATE INDEX idx_sessions_spot ON public.parking_sessions(spot);
CREATE INDEX idx_sessions_plate_norm ON public.parking_sessions(plate_norm);
CREATE INDEX idx_sessions_status ON public.parking_sessions(status);
CREATE INDEX idx_sessions_entry_time ON public.parking_sessions(entry_time DESC);

COMMENT ON TABLE public.parking_sessions IS 'Sessões de estacionamento (entrada → saída)';
COMMENT ON COLUMN public.parking_sessions.auto_payment_at IS 'Data/hora do débito automático na saída';
COMMENT ON COLUMN public.parking_sessions.status IS 'open = em curso | paid = pago auto | closed = saiu | payment_pending = aguarda pagamento | fine_pending = multa';


-- =====================================================
-- 6. PAGAMENTOS
-- =====================================================

CREATE TABLE public.parking_payments (
    id SERIAL PRIMARY KEY,
    session_id INTEGER NOT NULL REFERENCES public.parking_sessions(id) ON DELETE CASCADE,
    user_id INTEGER NULL REFERENCES public.parking_users(id) ON DELETE SET NULL,
    payment_method_id INTEGER NULL REFERENCES public.parking_user_payment_methods(id) ON DELETE SET NULL,
    amount NUMERIC(10, 2) NOT NULL,
    payment_type TEXT NOT NULL CHECK (payment_type IN ('parking', 'reservation_fine', 'manual')),
    method TEXT NOT NULL DEFAULT 'auto_debit',  -- 'auto_debit', 'manual', 'cash'
    reference TEXT NULL,
    paid_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    metadata JSONB NULL
);

CREATE INDEX idx_payments_session_id ON public.parking_payments(session_id);
CREATE INDEX idx_payments_user_id ON public.parking_payments(user_id);
CREATE INDEX idx_payments_paid_at ON public.parking_payments(paid_at DESC);

COMMENT ON TABLE public.parking_payments IS 'Pagamentos efetuados (estacionamento e multas)';
COMMENT ON COLUMN public.parking_payments.payment_type IS 'parking = estacionamento | reservation_fine = multa de reserva não usada | manual = pagamento manual';


-- =====================================================
-- 7. NOTIFICAÇÕES (MOBILE)
-- =====================================================

CREATE TABLE public.parking_notifications (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES public.parking_users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    body TEXT NOT NULL,
    notification_type TEXT NOT NULL CHECK (notification_type IN (
        'parked',           -- Onde estacionou
        'reservation_violation',  -- Alguém estacionou na sua reserva
        'violation_alert',  -- (Admin) Alguém estacionou em lugar reservado
        'payment',          -- Pagamento efetuado
        'fine',             -- Multa aplicada
        'general'           -- Outras notificações
    )),
    data JSONB NULL,       -- Dados extra (ex: spot, plate, amount)
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

CREATE INDEX idx_notifications_user_id ON public.parking_notifications(user_id);
CREATE INDEX idx_notifications_created_at ON public.parking_notifications(created_at DESC);
CREATE INDEX idx_notifications_is_read ON public.parking_notifications(is_read);

COMMENT ON TABLE public.parking_notifications IS 'Notificações push para a app mobile';


-- =====================================================
-- 8. LOG DE EVENTOS (mantido da versão anterior)
-- =====================================================

CREATE TABLE public.parking_event_log (
    id SERIAL PRIMARY KEY,
    detected_plate TEXT NULL,
    final_plate TEXT NULL,
    det_confidence NUMERIC(5, 2) NULL,
    ocr_confidence NUMERIC(5, 2) NULL,
    image_path TEXT NULL,
    camera_id TEXT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

CREATE INDEX idx_event_log_camera ON public.parking_event_log(camera_id);
CREATE INDEX idx_event_log_created ON public.parking_event_log(created_at DESC);


-- =====================================================
-- DADOS INICIAIS
-- =====================================================
-- Os utilizadores serão criados via endpoint de registo.
-- Não são necessários INSERTs manuais.
--
-- Após criar as tabelas, registe os utilizadores via frontend:
--
-- 1. ADMIN:
--    Email: admin@tugapark.pt
--    Password: (a sua escolha)
--    Nome: Administrador
--    DEPOIS: Executar SQL para mudar role para 'admin':
--    UPDATE public.parking_users SET role = 'admin' WHERE email = 'admin@tugapark.pt';
--
-- 2. CLIENTE:
--    Email: cliente@teste.pt
--    Password: (a sua escolha)
--    Nome: Cliente Teste
--
-- =====================================================


-- =====================================================
-- FUNÇÕES ÚTEIS
-- =====================================================

-- Função para verificar se reserva é válida (hoje ou amanhã)
CREATE OR REPLACE FUNCTION check_reservation_date()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.reservation_date < CURRENT_DATE THEN
        RAISE EXCEPTION 'Não é possível fazer reservas para datas passadas';
    END IF;
    IF NEW.reservation_date > CURRENT_DATE + INTERVAL '1 day' THEN
        RAISE EXCEPTION 'Só é possível fazer reservas para hoje ou amanhã';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_check_reservation_date
    BEFORE INSERT OR UPDATE ON public.parking_manual_reservations
    FOR EACH ROW
    EXECUTE FUNCTION check_reservation_date();


-- Função para aplicar multas de reservas não usadas
-- Deve ser executada diariamente via cron job
CREATE OR REPLACE FUNCTION apply_reservation_fines()
RETURNS INTEGER AS $$
DECLARE
    fines_count INTEGER := 0;
    reservation RECORD;
BEGIN
    -- Encontrar reservas de ontem que não foram usadas
    FOR reservation IN
        SELECT r.*, u.id as owner_id
        FROM public.parking_manual_reservations r
        JOIN public.parking_users u ON r.user_id = u.id
        WHERE r.reservation_date = CURRENT_DATE - INTERVAL '1 day'
          AND r.was_used = FALSE
          AND r.fine_applied = FALSE
    LOOP
        -- Marcar multa como aplicada
        UPDATE public.parking_manual_reservations
        SET fine_applied = TRUE
        WHERE id = reservation.id;
        
        -- Criar notificação de multa
        INSERT INTO public.parking_notifications (user_id, title, body, notification_type, data)
        VALUES (
            reservation.owner_id,
            'Multa por reserva não utilizada',
            'Foi aplicada uma multa de 20€ por não ter utilizado a reserva do lugar ' || reservation.spot,
            'fine',
            jsonb_build_object('spot', reservation.spot, 'amount', 20, 'date', reservation.reservation_date)
        );
        
        fines_count := fines_count + 1;
    END LOOP;
    
    RETURN fines_count;
END;
$$ LANGUAGE plpgsql;


-- =====================================================
-- RESUMO DAS TABELAS
-- =====================================================
-- 1. parking_users           - Utilizadores (email, password, role)
-- 2. parking_user_vehicles   - Veículos (multi-carros por utilizador)
-- 3. parking_user_payment_methods - Cartões de crédito
-- 4. parking_manual_reservations  - Reservas (só hoje/amanhã)
-- 5. parking_sessions        - Sessões de estacionamento
-- 6. parking_payments        - Pagamentos
-- 7. parking_notifications   - Notificações mobile
-- 8. parking_event_log       - Log de eventos ALPR
-- =====================================================
